package main

import (
	"fmt"
	"sort"
	"strings"
)

// sortString – моя вспомогательная функция.
// Она принимает строку, переводит её в нижний регистр,
// сортирует символы и возвращает как новую строку.
// Нужна для того, чтобы из любых перестановок букв
// (анограмм) получить одинаковый ключ.
func sortString(s string) string {
	runes := []rune(strings.ToLower(s)) // перевожу строку в []rune, чтобы работали русские буквы
	sort.Slice(runes, func(i, j int) bool {
		return runes[i] < runes[j] // сортирую по алфавиту
	})
	return string(runes) // возвращаю отсортированную строку
}

// Anagramer – основная функция.
// На вход подаю массив строк, а на выходе получаю
// map, где ключ – "человеческое слово", а значение – список всех его анаграмм.
func Anagramer(str []string) map[string][]string {
	groups := make(map[string][]string) // сюда складываю группы по техническому ключу (отсортированные буквы)
	result := make(map[string][]string) // сюда уже красивый результат для вывода

	// Прохожусь по каждому слову и группирую их по ключу
	for _, w := range str {
		key := sortString(w)                 // ключ – это отсортированное слово
		groups[key] = append(groups[key], w) // добавляю слово в соответствующую группу
	}

	// Теперь беру только те группы, где больше 1 слова (иначе не анаграммы)
	for _, group := range groups {
		if len(group) > 1 {
			sort.Strings(group) // сортирую сами слова внутри группы для красоты
			// в качестве "человеческого" ключа беру первое слово группы
			result[group[0]] = group
		}
	}

	return result
}

func main() {
	// Мой тестовый набор слов. Тут есть две группы анаграмм и одно слово без пары ("стол").
	str := []string{"пятак", "пятка", "тяпка", "листок", "слиток", "столик", "стол"}

	// Вывожу результат. Для каждой группы показываю "ключевое слово" и список его анаграмм.
	for key, group := range Anagramer(str) {
		fmt.Printf("%q: %v\n", key, group)
	}
}
