package main

import (
	"fmt"
	"math/rand"
	"time"
)

// asChan принимает список чисел и возвращает канал,
// в который эти числа будут отправляться по одному с задержкой
func asChan(vs ...int) <-chan int {
	c := make(chan int) // создаём канал для передачи чисел
	go func() { // запускаем горутину, чтобы не блокировать основную функцию
		for _, v := range vs {
			c <- v // отправляем число в канал (заблокируется, пока кто-то не прочтёт)
			// случайная задержка до 1 секунды, чтобы числа "приходили" в разном порядке
			time.Sleep(time.Duration(rand.Intn(1000)) * time.Millisecond)
		}
		close(c) // когда все числа отправлены — закрываем канал
	}()
	return c // возвращаем канал только для чтения
}

// merge объединяет два канала (a и b) в один канал c
func merge(a, b <-chan int) <-chan int {
	c := make(chan int) // результирующий канал
	go func() { // запускаем горутину, чтобы слушать оба канала одновременно
		for {
			select {
			case v, ok := <-a: // читаем из канала a
				if ok {
					c <- v // если канал открыт, пересылаем значение дальше
				} else {
					a = nil // если канал закрыт — обнуляем его, чтобы select его больше не выбирал
				}
			case v, ok := <-b: // читаем из канала b
				if ok {
					c <- v // если канал открыт, пересылаем значение дальше
				} else {
					b = nil // если канал закрыт — отключаем его
				}
			}
			// если оба канала закрыты — закрываем результирующий и выходим
			if a == nil && b == nil {
				close(c)
				return
			}
		}
	}()
	return c // возвращаем объединённый канал
}

func main() {
	rand.Seed(time.Now().Unix()) // инициализация генератора случайных чисел
	a := asChan(1, 3, 5, 7)      // первый поток чисел
	b := asChan(2, 4, 6, 8)      // второй поток чисел
	c := merge(a, b)             // объединяем два потока в один

	// читаем из объединённого канала и печатаем числа
	// порядок будет случайным из-за задержек в asChan
	for v := range c {
		fmt.Print(v)
	}
}

/*select в Go — это конструкция, похожая по синтаксису на switch, но работает она с каналами.
Она позволяет слушать сразу несколько операций чтения/записи.
Как только хотя бы один канал готов — выполняется соответствующий case.
Если готовых несколько — планировщик Go случайным образом выбирает один.
Если не готов ни один — select блокируется, пока что-то не станет доступно (если нет default).*/
