package main

import (
	"fmt"
)

func main() {
	ch := make(chan int) // создаем небуферизованный канал типа int
	go func() { // в горутине запускается цикл, где значения от 0 до 9 отправляются в канал
		for i := 0; i < 10; i++ {
			ch <- i // каждая отправка блокируется, пока в main не будет готов приём из канала
		} // таким образом происходит синхронизация между отправкой и приёмом
		// close(ch) // <- вот это нужно, чтобы избежать deadlock
	}()
	for n := range ch { // читаем данные из канала, пока канал не закрыт
		fmt.Println(n) // вывод: 0 1 ... 8 9, а потом deadlock
	}
}

/*
Почему произошёл deadlock?
Потому что мы после всех отправок не закрыли канал, а цикл `range` ждёт новые данные.
Но горутина уже завершила работу, и никто больше не пишет в канал.
В результате main-горутина блокируется.

Чтобы этого не было, нужно закрыть канал:
close(ch)

Тогда вывод будет: 0 1 ... 8 9
и программа завершится корректно.
*/
